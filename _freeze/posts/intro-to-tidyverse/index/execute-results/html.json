{
  "hash": "78da53a73dc49ed6a762d72272cfb092",
  "result": {
    "markdown": "---\ntitle: \"Intro a Tidyverse\"\ndescription: \"Mini tutorial a la library más útil de R\"\nauthor: \"David Humberto Jiménez S.\"\ndate: \"2020-04-18\"\ndate-modified: \"2023-11-19\"\ncategories: [tutorial, code, analysis, visualization]\nimage: \"intro-dplyr.png\"\n---\n\n\n## Pequeña intro\nR es un lenguaje de programación pensado para profesionales de las matemáticas y de la estadística. En este sentido, es un software con mucha historia (desde los 70's aproximadamente). Por esta razón se ha tenido que actualizar y mejorar. Esto se ha debido, principalmente, a la gran comunidad de usuarios y a que es un software gratuito y de código abierto. Esto quiere decir que todas lo pueden modificar y adaptar de acuerdo a sus necesidades.\n\nPor esta razón, se han creado herramientas para el análisis de datos: [Tidyverse](https://www.tidyverse.org/)\n\nR tiene una sintaxis base (a partir de ahora, R base). Sin embargo, como cualquier otro lenguaje, las palabras, cosas y significados cambian a lo largo del tiempo. Tidyverse nos permite realizar distintas operaciones sobre bases de datos (además de que me parece más amigable que R base).\n\nA estar herramientas adicionales se les llama paquetes (*packages*) y deben ser instaladas. Una vez instaladas, solo deben \"activarse\" cada vez que serán utilizadas (*library*). \n\nEn este caso, tidyverse es un conjunto de paquetes: \n- ggplot (visualización/gráficas)\n- dplyr (manipulación de bases de datos)\n- tidyr (arreglo/acomodar bases de datos)\n- readr (importar \"leer\" archivos)\n- tibble (creación de bases de datos, *data frames*)\n- stringr (funciones para textos, *strings*)\n- forcats (funciones para factores)\n\nBueno, esto ya fue mucho choro. Vamos a jugar un rato. Para ejecutar el código abajo debes tener instalado [R](https://cran.r-project.org/mirrors.html), [R studio](https://rstudio.com/products/rstudio/download/), así como tidyverse *install.packages(\"tidyverse\")* en tu script. \n\n## dplyr y ggplot\n\nEn este caso, vamos a utilizar las bases de datos que vienen por default en ggplot. Por lo que no tendrás que descargar nada (por ahora). Una forma de presentar nuestros resultados es a través de tablas y gráficas. Empezaremos con cosas sencillas, hasta hacerlas complejas y bonitas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\nPara mi, me funciona colocar las *libraries* al principio del script. Esto me ayuda a tener claridad de que paquetes estoy utilizando.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- diamonds\n\ndim(datos)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 53940    10\n```\n:::\n:::\n\n\n\"datos\" es el nombre que le puse a la base de datos (si lo nombramos existe :D). \n\"diamonds\" es la base de datos dentro del paquete ggplot2. Contiene información de precios, calidad y quilates de 53,940 diamantes, en 10 columnas. ¿Qué cómo sé eso? por la función dim: número de renglones y número de columnas. Para información adicional, pueden revisar la página de Kaggle sobre este [*dataset*](https://www.kaggle.com/datasets/shivam2503/diamonds)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(datos)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     carat               cut        color        clarity          depth      \n Min.   :0.2000   Fair     : 1610   D: 6775   SI1    :13065   Min.   :43.00  \n 1st Qu.:0.4000   Good     : 4906   E: 9797   VS2    :12258   1st Qu.:61.00  \n Median :0.7000   Very Good:12082   F: 9542   SI2    : 9194   Median :61.80  \n Mean   :0.7979   Premium  :13791   G:11292   VS1    : 8171   Mean   :61.75  \n 3rd Qu.:1.0400   Ideal    :21551   H: 8304   VVS2   : 5066   3rd Qu.:62.50  \n Max.   :5.0100                     I: 5422   VVS1   : 3655   Max.   :79.00  \n                                    J: 2808   (Other): 2531                  \n     table           price             x                y         \n Min.   :43.00   Min.   :  326   Min.   : 0.000   Min.   : 0.000  \n 1st Qu.:56.00   1st Qu.:  950   1st Qu.: 4.710   1st Qu.: 4.720  \n Median :57.00   Median : 2401   Median : 5.700   Median : 5.710  \n Mean   :57.46   Mean   : 3933   Mean   : 5.731   Mean   : 5.735  \n 3rd Qu.:59.00   3rd Qu.: 5324   3rd Qu.: 6.540   3rd Qu.: 6.540  \n Max.   :95.00   Max.   :18823   Max.   :10.740   Max.   :58.900  \n                                                                  \n       z         \n Min.   : 0.000  \n 1st Qu.: 2.910  \n Median : 3.530  \n Mean   : 3.539  \n 3rd Qu.: 4.040  \n Max.   :31.800  \n                 \n```\n:::\n\n```{.r .cell-code}\ndatos <- datos %>%\n    select(-c(x, y, z)) %>%\n    filter(price >= 1000)\n```\n:::\n\n\nEn este *chunk*,  o pedazo de código, la función *summary* nos da un resumen de como están distribuidas las variables. Mientras que **%>%** es un operador llamado *pipe* que funciona con dplyr y nos permite realizar operaciones secuenciales; esto significa que va a ser como una cascada: del conjunto de datos ejecuta la operación select y luego la operación filter. \n\nAsí pues, *select* nos permite mantener o eliminar columnas de una base de datos. La parte c() es para indicar una selección de columnas, en este caso las columnas llamadas \"x\", \"y\" y \"z\". Mientras que el signo negativo **-** que le antecede indica que esa selección se va a eliminar. Por último, la función *filter* es un filtro para quedarnos solo con los datos que cumplan la condición: que el preció sea mayor o igual a mil dólares. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = cut)) +\n    geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nUna gráfica de barras es, originalmente, una gráfica de una sola variable.\n\nIgual que en dplyr, ggplot ejecuta operaciones secuenciales: primero necesita la base de datos a graficar (datos), luego en aes (aesthetics) van las variables principales a graficar. Es decir, el \"eje x\" y \"eje y\". Este tipo de gráficas sencillas son muy útiles para explorar los datos. Y por lo tanto se pueden complejizar para obtener mejores lecturas, intuiciones y llegar a conocimiento. Pero vamos paso a paso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = cut, fill = color)) +\n    geom_bar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nEn este *chunk¨la el parametro *fill* nos permite incluir variables categóricas dentro de las barras. Esto quiere decir, aquellas categorías que son mutuamente excluyentes, en este caso si un diamante es color \"D\", no puede ser al mismo tiempo de color \"J\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = cut, fill = color)) +\n    geom_bar(position = \"dodge\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nComo ya separamos cada barra en categorías, separarlas a lo largo del eje puede ser una buena opción.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = cut, fill = color)) +\n    geom_bar(position = \"dodge\") +\n    labs(\n        title = \"Mi primera gráfica\",\n        subtitle = \"Datos de diamantes\",\n        y = \"\", x = \"Corte\",\n        caption = \"Fuente: Kaggle\",\n        fill = \"Colores\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nLa función labs es muy útil para modificar las gráficas y es bastante intuitiva. En este caso, todo lo que está en comillas son textos (*strings*). Y en el caso del eje *Y* se elimina la etiqueta del conteo. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(datos, aes(x = cut, fill = color)) +\n    geom_bar(position = \"dodge\") +\n    labs(\n        title = \"Mi primera gráfica\",\n        subtitle = \"Datos de diamantes\",\n        y = \"\", x = \"corte\",\n        caption = \"Fuente: Kaggle\",\n        fill = \"Colores\"\n    ) +\n    coord_flip() +\n    theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nLa función coord flip nos permite girar a la izquierda nuestra gráfica, mientras que la función theme_classic() cambia como se ve la gráfica final. \n\nEste post es una versión revisada de la primera iteración de este blog y tiene como intención servir de tutorial para el análisis de datos. ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}